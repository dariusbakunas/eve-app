# source: http://localhost:4000/graphql
# timestamp: Sat Dec 14 2019 16:30:37 GMT-0500 (Eastern Standard Time)

type Alliance {
  id: ID!
  name: String!
  ticker: String!
}

type Character {
  id: ID!
  corporation: Corporation!
  name: String!
  gender: String!
  scopes: [String!]
  birthday: DateTime!
  securityStatus: Float!
  skillGroups: [SkillGroup!]!
  skillGroup(id: ID!): SkillGroup
  totalSp: Int
}

type Client {
  id: ID!
  name: String!
  category: String!
}

type Corporation {
  id: ID!
  alliance: Alliance
  dateFounded: DateTime
  name: String!
  memberCount: Int!
  taxRate: Float!
  ticker: String!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format
outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for
representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type InventoryItem {
  id: ID!
  name: String
  description: String
}

type JournalEntries {
  total: Int!
  entries: [JournalEntry!]!
}

type JournalEntry {
  id: ID!
  amount: Float!
  balance: Float!
  character: Character!
  date: DateTime!
  description: String
}

type Location {
  id: ID!
  name: String!
}

type MarketOrder {
  id: ID!

  """Character who issued the order"""
  character: Character!

  """
  Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
  """
  duration: Int!

  """For buy orders, the amount of ISK in escrow"""
  escrow: Float

  """Item transacted in this order"""
  item: InventoryItem!

  """True if this is buy order"""
  isBuy: Boolean!

  """
  Signifies whether the buy/sell order was placed on behalf of a corporation
  """
  isCorporation: Boolean!

  """Location where order was placed"""
  location: Location!

  """
  For buy orders, the minimum quantity that will be accepted in a matching sell order
  """
  minVolume: Int

  """Date and time when this order was issued"""
  issued: DateTime!

  """Cost per unit for this order"""
  price: Float!

  """Valid order range, numbers are ranges in jumps"""
  range: String!

  """Quantity of items still required or offered"""
  volumeRemain: Int!

  """Quantity of items required or offered at time order was placed"""
  volumeTotal: Int!

  """Current order state"""
  state: OrderState!
}

input MarketOrderFilter {
  characterId: ID
  state: OrderStateFilter
}

enum MarketOrderOrderBy {
  issued
}

input MarketOrderOrderByInput {
  column: MarketOrderOrderBy!
  order: Order!
}

type MarketOrders {
  total: Int!
  orders: [MarketOrder!]!
}

type Mutation {
  addCharacter(code: String!): Character!
  updateCharacter(id: ID!, code: String!): Character!
  removeCharacter(id: ID!): ID!
  register(input: RegistrationInput!): User!
  addItemsToWarehouse(id: ID!, input: [NewWarehouseItemInput!]!): [WarehouseItem!]!
  removeItemsFromWarehouse(id: ID!, itemId: ID!, quantity: Int!): WarehouseItem
  addWarehouse(name: String!): Warehouse!
  removeWarehouse(id: ID!): ID!
  updateWarehouse(id: ID!, name: String!): Warehouse!
}

input NewWarehouseItemInput {
  id: ID!
  quantity: Int!
  unitCost: Float!
}

enum Order {
  asc
  desc
}

enum OrderState {
  active
  cancelled
  expired
}

input OrderStateFilter {
  active: Boolean
  expired: Boolean
  cancelled: Boolean
}

enum OrderType {
  buy
  sell
}

input PageInput {
  index: Int = 0
  size: Int = 10
}

enum ProcessingCategory {
  WALLET_TRANSACTIONS
  WALLET_JOURNAL
  BOOKMARKS
  MARKET_ORDERS
  ASSETS
  CALENDAR
  BLUEPRINTS
  CLONES
  IMPLANTS
  CONTACTS
  INDUSTRY_JOBS
  STATS
  SKILLS
  SKILL_QUEUE
}

type ProcessingLogEntry {
  id: ID!
  createdAt: DateTime!
  character: Character
  category: ProcessingCategory!
  status: ProcessingStatus!
  message: String!
  error: String
}

input ProcessingLogFilter {
  characterId: ID
}

enum ProcessingStatus {
  SUCCESS
  FAILURE
}

type Query {
  character(id: ID!): Character
  characters: [Character!]!
  processingLogs(filter: ProcessingLogFilter): [ProcessingLogEntry!]!
  scopes: [Scope!]!
  userByEmail(email: String!): User
  marketOrders(page: PageInput, filter: MarketOrderFilter, orderBy: MarketOrderOrderByInput): MarketOrders!
  walletJournal(page: PageInput, filter: WalletJournalFilter, orderBy: WalletJournalOrderByInput): JournalEntries!
  walletTransactions(page: PageInput, filter: WalletTransactionFilter, orderBy: WalletTransactionOrderByInput): WalletTransactions!
  walletTransactionSummary(ids: [ID!]!): WalletTransactionSummary!
  walletTransactionIds(filter: WalletTransactionFilter): [ID!]!
  warehouse(id: ID!): Warehouse
  warehouses: [Warehouse!]!
}

input RegistrationInput {
  firstName: String
  lastName: String
  username: String!
  email: String!
  code: String!
}

type Scope {
  id: ID!
  name: String!
}

type Skill {
  id: ID!
  name: String!
  multiplier: Int
  activeSkillLevel: Int
  trainedSkillLevel: Int
  skillPointsInSkill: Int
}

type SkillGroup {
  id: ID!
  name: String!
  skills: [Skill!]!
  totalSp: Int
  totalLevels: Int
  trainedSp: Int
}

"""
A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format
outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for
representation of dates and times using the Gregorian calendar.
"""
scalar Time

type User {
  id: ID!
  username: String!
  firstName: String
  lastName: String
  email: String!
  status: UserStatus!
}

enum UserStatus {
  ACTIVE
  INACTIVE
}

input WalletJournalFilter {
  characterId: ID
}

enum WalletJournalOrderBy {
  date
  amount
  character
  balance
  description
}

input WalletJournalOrderByInput {
  column: WalletJournalOrderBy!
  order: Order!
}

type WalletTransaction {
  id: ID!
  credit: Float!
  client: Client!
  character: Character!
  date: DateTime!
  isBuy: Boolean!
  item: InventoryItem!
  location: Location!
  quantity: Int!
  unitPrice: Float!
}

input WalletTransactionFilter {
  ids: [ID!]
  item: String
  characterId: ID
  orderType: OrderType
}

enum WalletTransactionOrderBy {
  date
  client
  character
  credit
  item
  quantity
  station
  unitPrice
}

input WalletTransactionOrderByInput {
  column: WalletTransactionOrderBy!
  order: Order!
}

type WalletTransactions {
  total: Int!
  lastUpdate: DateTime
  transactions: [WalletTransaction!]!
}

type WalletTransactionSummary {
  items: [WalletTransactionSummaryItem!]!
}

type WalletTransactionSummaryItem {
  id: ID!
  name: String!
  quantity: Int!
  credit: Float!
}

type Warehouse {
  id: ID!
  name: String!
  items: [WarehouseItem!]!
}

type WarehouseItem {
  id: ID!
  name: String!
  quantity: Int!
  unitCost: Float!
}
